---
title: Takt - Software Development as a Pull System
author: Lars Kruse
search: true
author_profile: true
comments: true
header:
  teaser: /assets/images/posts/takt/takt2x1.jpg
tags:
  - services
excerpt: The takt concept derives from lean manufacturing, but how does it apply to lean software development
# cspell:ignore 
---

![image-center](/assets/images/posts/takt/takt.jpg){: .align-center width="50%"}

## Takt

**In the Toyota Production System (TPS), Takt (or Takt Time) is one of the foundational flow concepts. It comes from the German word _Takt_, meaning rhythm, beat, or meter ‚Äî like the steady beat that keeps an orchestra in sync.**

**Takt** is _also_ the name of an Open Source GitHub CLI extension that you can use in your current flow. It enables you to evolve a Quality-by-Design compliant workflow free of blocking Pull Requests while keeping you main branch _always shippable_.<br/>[Get **Takt** from GitHub](https://github.com/devx-cafe/gh-tt){: target="_blank" .btn .btn--warning title="Opens in a new tab"}
{: .fact .right .small}

In Lean Manufacturing Takt is the rate at which a product must be produced to meet customer demand.
It synchronizes production with real demand so the system neither overproduces _(muri)_ nor starves downstream processes _(mura)_.

Takt is often described a heartbeat:

- If the heartbeat is too slow, customers aren‚Äôt served.
- If it‚Äôs too fast, the system is stressed or overproduces.

A Lean principle is to keep the heartbeat steady and healthy.

The takt time is calculated as:

```bash
Takt Time = Available Production Time / Customer Demand
```

Asking _"How many production hours do we have available on the workforce and how many cars do we have to deliver?"_, divide and you get the takt time.

Intuitively this formula appears to makes more sense in manufacturing than it does in Software Development, so let's try to translate the semantics into what it means in our realm; Software Development.

The takt time helps us shift thinking from "how long will this take?" to "what pace must we maintain?"

**Takt Is Not** the same as _cycle time_ (how long the work takes), and it's also not the same as _lead time_ (end-to-end time) and it's definitely not an encouragement to "work faster".

**Takt Is** a core concept to understand the fundamental difference in a _push-system (Theory of Constraints)_ as opposed to a _pull-system (Minimize Work In Progress, One-Piece flow, Kanban)_  

## üß© How Takt, Cycle Time, Lead Time, and WIP Fit Together

A common challenge in Software Development is the dreaded "Iron Triangle" where _time_, _quality_ and _cost_ are all locked in as non-negotiable. It's the driver for Brooks Law:

> _"adding manpower to a late software project makes it later"_

Brook even argues that his own law doesn't apply to Open Source software products simply because; _...there are no deadlines._ ‚Äî time is not a factor.

More often than not, the iron triangle implode, reality won't play along and a new budget and new deadline is offered. Now Software Developers are locked down in estimation of new features or re-estimation of existing ones to be able to update and communicate the new variables in the Iron Triangle.

Only to find themselves ‚Äî a month from now ‚Äî getting a new push, making new estimates and new adjustments in the Iron Triangle variables because, as we know; _"no battle plan survives encounter with the battle field"_.

What if we could escape this Iron Triangle trap?

{% responsive_image
  path: "assets/images/posts/takt/takt-cycle.png"
  alt: "Concepts connected"
  caption: "Limit WIP ‚Üí stabilize flow ‚Üí improve cycle time ‚Üí match takt ‚Üí shorten lead time. ‚Äî It's all connected"
  class: "pic right small"
%}

The Toyota Production System and Lean principles defies this way of thinking and replaces this relentless _push_  with a _pull_

Take offset in your own current situation, ask yourself _"how much can we produce"_. Measured against the actual demand; _"how much should we produce"_ and contemplate _"is there any way we can optimize the internal workings of our Value Stream to reach that pace"_.

Four core concepts are connected as system:

üëâ **Takt** = the pace you need<br/>
üëâ **Cycle Time** = the pace you actually work at<br/>
üëâ **Lead Time** = the customer-felt wait from request to delivery<br/>
üëâ **Work In Progress (WIP)** = the amount of stuff in progress that affects everything above.

### 1. Takt Time ‚Äî _Required Output Pace_

_The rate at which you must complete items to meet customer demand._

**Software analogy:**

Imagine that you managed to have that difficult conversation with business, that the Iron Triangle is crap and you need a different approach and you make them accept that your team can do _40 deployable changes per week_, and your calculate that your team team has _200 effective hours of work per week_, your takt is simply:

```bash
200 hours / 40 changes ‚âà 5 hours per deployable change
```

This becomes the desired rhythm. The takt time.

### 2. Cycle Time ‚Äî _Actual Work Time per Item_

_How long it takes to do the work ‚Äî including idle time and waiting._

**Software example:**

The following are just imagined chores involved in completing a deployable change, they may vary in different teams and projects, but the point is that includes both _process time_ and _idle time_.

```ini
                             Problem analysis
+                                        idle
+                              Developer time
+                                        idle
+                     Meet quality thresholds
+                                        idle
+                                Peer reviews
+                                        idle
+                        Update documentation
+                                        idle
+                          Update audit trail
+                                        idle
+                         Update release note
+                                        idle
+                         CI workflow runtime
+                                        idle
+                 Deployment workflow runtime
   ------------------------------------------
=                                  Cycle Time
   ==========================================
```

If your _Cycle Time_ is longer than the _Takt Time_ you cannot meet demand ‚Üí You have a bottleneck. You will have to _optimize_ your Value Stream.

In low performing systems, it's often the idle time that is the bugger, It's easy to imagine that the more bureaucratic red-tape, impractical tooling, unfruitful discussions about cost and deadlines, continuous re-estimation of plans and just hand-overs in general, the more time is wasted.

### 3. Lead Time ‚Äî _Total Duration From Request to Delivery_

Does your software development process have a high focus on quality and maybe even compliancy with regulatory rules and Quality-by-Design principles? Does it need a checkup?<br/>&nbsp;&nbsp;&nbsp;Read my article on **_Continuous Delivery in regulated, safety-critical or high-risk products_** and learn how I may be able to help you.<br/>[Read the article](/stories/cd-in-regulated-prod/){: .btn .btn--warning title="Continuous Delivery in regulated, safety-critical or high-risk products"}
{: .fact .right .small}

_It is the customer-felt wait from request to delivery._

This is what matters most to customers. Lead time includes _everything_: That is, the _Cycle Time_ and _everything_ else:

- Ideation
- Gathering requirements
- Design
- Time spent on social events among employees
- Stand up meetings and other team rituals
- System architecture workshops
- Setting up extra infrastructure to conduct an experiment
- Employees Vacation
- Waiting in queues
- Resources spent elsewhere to pile up stock
- Company X-mas lunch
- All the time spent in Cycle Time
- _Every freaking thing!_

Lead time tells you how healthy your system is. If lead time is long, it‚Äôs because your Value Stream is ineffective and needs optimization. You must continuously optimize both _Muda (wastefullness), mura (unevenness)_ and _muri (overburdenness)_.

### 4. WIP ‚Äî _Work in Progress_

_The amount of stuff in progress that affects everything_

**One-Piece Flow** ‚Äî Toyota Production System and Lean principles advocates a _one-piece flow_ a process where the cycle time is optimized to deal with exactly _one_ issue a time. The argument is that a one-piece flow will surface problems _immediately_  and enable you to deal with them _at the source_ in context where the problem can be analyzed. This ensures that no flaw or defect is passed on the the next process. _Jidoka_ is a commonly used term, often referred to as _build-in quality_ ‚Äî as opposed to the alternative; to glue it on later as an afterthought.

**Minimize Work in Progress** ‚Äî The ideal to _minimize Work In Progress_ allows us to ovoid task switching, to keep focus, to minimize the cognitive load, to constantly reflect and Continuously Improve _(Kaizen)_. It prevents us from building up stock (which we don't need) and it allows us to see and argue _for S.M.E.D.[^smed] sized_ improvements.

[^smed]: Toyota‚Äôs SMED (Single-Minute Exchange of Die) principle is a lean manufacturing methodology designed to drastically reduce the time it takes to complete equipment changeovers or production setups. Due to the extremely high (positive) impact on Cycle Time, it‚Äôs considered justified even if the development of that improvement may assume quite an extensive effort.

High WIP ‚Üí

- longer lead times
- worse quality
- more context switching
- slower feedback
- unpredictable delivery
- higher cognitive load
- more burnout

Low WIP ‚Üí

- shorter lead times
- fewer defects
- stable flow
- easier forecasting

WIP is the ‚Äúlever‚Äù that enables takt and cycle time alignment.
The _one piece flow_ forces problems to surface early and to control the quality at the source.

**_Limit WIP ‚Üí stabilize flow ‚Üí improve cycle time ‚Üí match takt ‚Üí shorten lead time_**

## How to Continuously Optimize

When we argue for _Lean Software Development_ it's a devotion to _pull_ over _push_ and to a relentless continuous improvement of flow, with a bias to _Long-term system thinking_.

### ‚≠ê Step 1 ‚Äî Define ‚Äúcustomer demand‚Äù (Takt)

You need to break the evil spell of the Iron Triangle. Whoever the _customer_ translate to in your context you must school them to understand that _"I want all my features, within budget, on time and with stellar quality"_  isn't how it works. Everybody wins when the team use time on optimizing flow instead of re-estimating fantasy deliveries.

### ‚≠ê Step 2 ‚Äî Map your value stream

Investigate; Where does all the Cycle Time in the Value Stream go? _Value Stream Mapping_ is the tool used for this, it specifically maps _idle time_ and _process time_. It's not a once-over discipline, you continuously map the Value Stream to continuously improve.

### ‚≠ê Step 3 ‚Äî Look for the bottlenecks and pseudo work

What can you optimize? A lot of things probably, but look for the low-hanging fruits first. That would be _idle time_. Like the time that passes from someone requests a review and until someone else finally get's around to do it.

It's also likely that _pseudo work_ is stealing time from you pool of _effective hours per week._ Even if developers are employed 40 hours per week it doesn't mean that they have 40 effective hours per week to attend to software development. So even time _outside_ the Cycle Time loop is worth investigating.

DevX optimization examples (in a team of eight developers):

- Daily stand-ups that always start five minutes late and run five minutes over = 6.7 hours per week
- IT department pushes Microsoft updates to developers PC's, which crashes their dev tools it take 30 mins to reinstall, happens every month: ~1 hour per week
- Manually filling out extensive forms in Jira for each single issue; 5 mins peer issue, ~12 registrations per week: =8.3 hours per week.
- Forcing Developers to work on corporate standard Windows PC with active virus scan, it takes 30 mins to rebuild a Devcontainer, done daily, on Mac or Linux it takes 4 minutes: 17,3 hours per week

If you could clear ~33 hours and add that to the pool of _effective hours per week_. then it would mean either more time available per cycle (less need for optimization) or if you maintain the takt time; more deployable changes per week.

**Original calculation**

```bash
200 hours / 40.0 changes ‚âà 5.0 hours per deployable change
```

**After the optimization**

```bash
233 hours / 40.0 changes ‚âà 5.8 hours per deployable change
233 hours / 46.6 changes ‚âà 5.0 hours per deployable change
```

To get started at home, try to interview the developers about _their_ perspective, what wastes their time?

When all your low-hanging fruits are pricked. You switch to only fix the _most important problems_ before the insignificant ones. Recall the S.M.E.D analogy mentioned earlier. Maintaining the _priorities_ despite _high costs_ is how long-term system thinking works.

### ‚≠ê Step 4 ‚Äî Align cycle times to takt

Inside the cycle loop, even when _idle times_ are weeded out, _process time_ can be optimized.

Examples of stuff to improve:

- Parallelize CI runners
- Cache for build avoidance
- Improve static code analysis
- Improve test automation
- Automate IaC
- Automate Deploys
- Control quality at the source, skip the peer-reviews
- Improve Developers Experience (DevX)
- Remove review batching
- Reduce batch sizes (atomic commits)
- Pull work only when capacity exists (Minimize WIP)
- Reduce WIP limits per stage
- Introduce swarming (kaizen blitz) on blocked items
- Automate release-notes
- Build audit trail as you go
- Prioritized focuses on resolving a single, high-priority, or complex issue
- ...you get it right, _this list never ends!_

### ‚≠ê Step 5 ‚Äî Use Lead Time as the overall system health indicator

- If lead time shrinks as you improve your flow and weed out waste in the Value Stream things are working.
- If lead times grows, a hidden constraint appeared. Map your Value Stream again. Get your priorities straight.

## It's a mind game

This article argues for Continuous Delivery and lean software development.

DORA ‚Äî DevOps Research and Assessment institute release an annual "State of DevOps". report. They have curated four core metrics that they use to divide development teams into four performance levels: Elite, High, Medium and Low.

The four DORA metrics:

- Change lead times
- Deployment frequency
- Change failure (and rework) rate
- Failed deployment recovery time

{% responsive_image
  path: "assets/images/posts/takt/dora-businesscase.png"
  alt: "DORA 2024"
  caption: "Lead time up 127 times when comparing Elite and Low performers, The DORA survey from 2024 relies on 39K respondents. Click on the image to go to the post, scrutinizing the results of the 2024 State of DevOps report"
  class: "pic center medium"
  url: "/stories/state-of-devops-2024/"
%}

The distance between Elite and Low performers is mind blowing, so from that perspective _everybody_ should want to become an Elite performer. But in reality lean concepts ‚Äî and even DORA ‚Äî argues that the shift is not achieved by simply _doing_ something differently, it's achieved by _thinking_ differently.

Of course _long-term system thinking_ is the foundation of this mental shift, but also the _pull_ that must replace the _push_ and the recognition of _Developer Experience_ as a core performance factor and the effect of _transformational leadership_ which opens up a whole new field of lean management principles and problem oriented didactics are all examples of _thinking_ that does not always play well with the established short-term Iron Triangle approach.

It's not necessarily a quick fix, but it is definitely a fun one.

**_If you are in a position where you think you could use a second opinion on your Software Development Life Cycle don't hesitate to reach out and let's have a chat - no charge!_**

[Book a call](https://calendly.com/lakruzz){: .btn .btn--warning target="_blank" title="Opens in a new tab"}

---
